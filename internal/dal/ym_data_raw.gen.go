// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"cmd/gate/main.go/internal/model"
)

func newYmDataRaw(db *gorm.DB, opts ...gen.DOOption) ymDataRaw {
	_ymDataRaw := ymDataRaw{}

	_ymDataRaw.ymDataRawDo.UseDB(db, opts...)
	_ymDataRaw.ymDataRawDo.UseModel(&model.YmDataRaw{})

	tableName := _ymDataRaw.ymDataRawDo.TableName()
	_ymDataRaw.ALL = field.NewAsterisk(tableName)
	_ymDataRaw.PagePath = field.NewString(tableName, "page_path")
	_ymDataRaw.OperatingSystemDetailed = field.NewString(tableName, "operating_system_detailed")
	_ymDataRaw.Browser = field.NewString(tableName, "browser")
	_ymDataRaw.Pageviews = field.NewInt32(tableName, "pageviews")
	_ymDataRaw.Users = field.NewInt32(tableName, "users")
	_ymDataRaw.ID = field.NewInt32(tableName, "id")
	_ymDataRaw.PageViewDate = field.NewTime(tableName, "page_view_date")
	_ymDataRaw.HourOfPageViewInTheFormatHh00 = field.NewString(tableName, "hour_of_page_view_in_the_format_hh_00")

	_ymDataRaw.fillFieldMap()

	return _ymDataRaw
}

type ymDataRaw struct {
	ymDataRawDo

	ALL                           field.Asterisk
	PagePath                      field.String
	OperatingSystemDetailed       field.String
	Browser                       field.String
	Pageviews                     field.Int32
	Users                         field.Int32
	ID                            field.Int32
	PageViewDate                  field.Time
	HourOfPageViewInTheFormatHh00 field.String

	fieldMap map[string]field.Expr
}

func (y ymDataRaw) Table(newTableName string) *ymDataRaw {
	y.ymDataRawDo.UseTable(newTableName)
	return y.updateTableName(newTableName)
}

func (y ymDataRaw) As(alias string) *ymDataRaw {
	y.ymDataRawDo.DO = *(y.ymDataRawDo.As(alias).(*gen.DO))
	return y.updateTableName(alias)
}

func (y *ymDataRaw) updateTableName(table string) *ymDataRaw {
	y.ALL = field.NewAsterisk(table)
	y.PagePath = field.NewString(table, "page_path")
	y.OperatingSystemDetailed = field.NewString(table, "operating_system_detailed")
	y.Browser = field.NewString(table, "browser")
	y.Pageviews = field.NewInt32(table, "pageviews")
	y.Users = field.NewInt32(table, "users")
	y.ID = field.NewInt32(table, "id")
	y.PageViewDate = field.NewTime(table, "page_view_date")
	y.HourOfPageViewInTheFormatHh00 = field.NewString(table, "hour_of_page_view_in_the_format_hh_00")

	y.fillFieldMap()

	return y
}

func (y *ymDataRaw) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := y.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (y *ymDataRaw) fillFieldMap() {
	y.fieldMap = make(map[string]field.Expr, 8)
	y.fieldMap["page_path"] = y.PagePath
	y.fieldMap["operating_system_detailed"] = y.OperatingSystemDetailed
	y.fieldMap["browser"] = y.Browser
	y.fieldMap["pageviews"] = y.Pageviews
	y.fieldMap["users"] = y.Users
	y.fieldMap["id"] = y.ID
	y.fieldMap["page_view_date"] = y.PageViewDate
	y.fieldMap["hour_of_page_view_in_the_format_hh_00"] = y.HourOfPageViewInTheFormatHh00
}

func (y ymDataRaw) clone(db *gorm.DB) ymDataRaw {
	y.ymDataRawDo.ReplaceConnPool(db.Statement.ConnPool)
	return y
}

func (y ymDataRaw) replaceDB(db *gorm.DB) ymDataRaw {
	y.ymDataRawDo.ReplaceDB(db)
	return y
}

type ymDataRawDo struct{ gen.DO }

type IYmDataRawDo interface {
	gen.SubQuery
	Debug() IYmDataRawDo
	WithContext(ctx context.Context) IYmDataRawDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IYmDataRawDo
	WriteDB() IYmDataRawDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IYmDataRawDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IYmDataRawDo
	Not(conds ...gen.Condition) IYmDataRawDo
	Or(conds ...gen.Condition) IYmDataRawDo
	Select(conds ...field.Expr) IYmDataRawDo
	Where(conds ...gen.Condition) IYmDataRawDo
	Order(conds ...field.Expr) IYmDataRawDo
	Distinct(cols ...field.Expr) IYmDataRawDo
	Omit(cols ...field.Expr) IYmDataRawDo
	Join(table schema.Tabler, on ...field.Expr) IYmDataRawDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IYmDataRawDo
	RightJoin(table schema.Tabler, on ...field.Expr) IYmDataRawDo
	Group(cols ...field.Expr) IYmDataRawDo
	Having(conds ...gen.Condition) IYmDataRawDo
	Limit(limit int) IYmDataRawDo
	Offset(offset int) IYmDataRawDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IYmDataRawDo
	Unscoped() IYmDataRawDo
	Create(values ...*model.YmDataRaw) error
	CreateInBatches(values []*model.YmDataRaw, batchSize int) error
	Save(values ...*model.YmDataRaw) error
	First() (*model.YmDataRaw, error)
	Take() (*model.YmDataRaw, error)
	Last() (*model.YmDataRaw, error)
	Find() ([]*model.YmDataRaw, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.YmDataRaw, err error)
	FindInBatches(result *[]*model.YmDataRaw, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.YmDataRaw) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IYmDataRawDo
	Assign(attrs ...field.AssignExpr) IYmDataRawDo
	Joins(fields ...field.RelationField) IYmDataRawDo
	Preload(fields ...field.RelationField) IYmDataRawDo
	FirstOrInit() (*model.YmDataRaw, error)
	FirstOrCreate() (*model.YmDataRaw, error)
	FindByPage(offset int, limit int) (result []*model.YmDataRaw, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IYmDataRawDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (y ymDataRawDo) Debug() IYmDataRawDo {
	return y.withDO(y.DO.Debug())
}

func (y ymDataRawDo) WithContext(ctx context.Context) IYmDataRawDo {
	return y.withDO(y.DO.WithContext(ctx))
}

func (y ymDataRawDo) ReadDB() IYmDataRawDo {
	return y.Clauses(dbresolver.Read)
}

func (y ymDataRawDo) WriteDB() IYmDataRawDo {
	return y.Clauses(dbresolver.Write)
}

func (y ymDataRawDo) Session(config *gorm.Session) IYmDataRawDo {
	return y.withDO(y.DO.Session(config))
}

func (y ymDataRawDo) Clauses(conds ...clause.Expression) IYmDataRawDo {
	return y.withDO(y.DO.Clauses(conds...))
}

func (y ymDataRawDo) Returning(value interface{}, columns ...string) IYmDataRawDo {
	return y.withDO(y.DO.Returning(value, columns...))
}

func (y ymDataRawDo) Not(conds ...gen.Condition) IYmDataRawDo {
	return y.withDO(y.DO.Not(conds...))
}

func (y ymDataRawDo) Or(conds ...gen.Condition) IYmDataRawDo {
	return y.withDO(y.DO.Or(conds...))
}

func (y ymDataRawDo) Select(conds ...field.Expr) IYmDataRawDo {
	return y.withDO(y.DO.Select(conds...))
}

func (y ymDataRawDo) Where(conds ...gen.Condition) IYmDataRawDo {
	return y.withDO(y.DO.Where(conds...))
}

func (y ymDataRawDo) Order(conds ...field.Expr) IYmDataRawDo {
	return y.withDO(y.DO.Order(conds...))
}

func (y ymDataRawDo) Distinct(cols ...field.Expr) IYmDataRawDo {
	return y.withDO(y.DO.Distinct(cols...))
}

func (y ymDataRawDo) Omit(cols ...field.Expr) IYmDataRawDo {
	return y.withDO(y.DO.Omit(cols...))
}

func (y ymDataRawDo) Join(table schema.Tabler, on ...field.Expr) IYmDataRawDo {
	return y.withDO(y.DO.Join(table, on...))
}

func (y ymDataRawDo) LeftJoin(table schema.Tabler, on ...field.Expr) IYmDataRawDo {
	return y.withDO(y.DO.LeftJoin(table, on...))
}

func (y ymDataRawDo) RightJoin(table schema.Tabler, on ...field.Expr) IYmDataRawDo {
	return y.withDO(y.DO.RightJoin(table, on...))
}

func (y ymDataRawDo) Group(cols ...field.Expr) IYmDataRawDo {
	return y.withDO(y.DO.Group(cols...))
}

func (y ymDataRawDo) Having(conds ...gen.Condition) IYmDataRawDo {
	return y.withDO(y.DO.Having(conds...))
}

func (y ymDataRawDo) Limit(limit int) IYmDataRawDo {
	return y.withDO(y.DO.Limit(limit))
}

func (y ymDataRawDo) Offset(offset int) IYmDataRawDo {
	return y.withDO(y.DO.Offset(offset))
}

func (y ymDataRawDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IYmDataRawDo {
	return y.withDO(y.DO.Scopes(funcs...))
}

func (y ymDataRawDo) Unscoped() IYmDataRawDo {
	return y.withDO(y.DO.Unscoped())
}

func (y ymDataRawDo) Create(values ...*model.YmDataRaw) error {
	if len(values) == 0 {
		return nil
	}
	return y.DO.Create(values)
}

func (y ymDataRawDo) CreateInBatches(values []*model.YmDataRaw, batchSize int) error {
	return y.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (y ymDataRawDo) Save(values ...*model.YmDataRaw) error {
	if len(values) == 0 {
		return nil
	}
	return y.DO.Save(values)
}

func (y ymDataRawDo) First() (*model.YmDataRaw, error) {
	if result, err := y.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.YmDataRaw), nil
	}
}

func (y ymDataRawDo) Take() (*model.YmDataRaw, error) {
	if result, err := y.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.YmDataRaw), nil
	}
}

func (y ymDataRawDo) Last() (*model.YmDataRaw, error) {
	if result, err := y.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.YmDataRaw), nil
	}
}

func (y ymDataRawDo) Find() ([]*model.YmDataRaw, error) {
	result, err := y.DO.Find()
	return result.([]*model.YmDataRaw), err
}

func (y ymDataRawDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.YmDataRaw, err error) {
	buf := make([]*model.YmDataRaw, 0, batchSize)
	err = y.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (y ymDataRawDo) FindInBatches(result *[]*model.YmDataRaw, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return y.DO.FindInBatches(result, batchSize, fc)
}

func (y ymDataRawDo) Attrs(attrs ...field.AssignExpr) IYmDataRawDo {
	return y.withDO(y.DO.Attrs(attrs...))
}

func (y ymDataRawDo) Assign(attrs ...field.AssignExpr) IYmDataRawDo {
	return y.withDO(y.DO.Assign(attrs...))
}

func (y ymDataRawDo) Joins(fields ...field.RelationField) IYmDataRawDo {
	for _, _f := range fields {
		y = *y.withDO(y.DO.Joins(_f))
	}
	return &y
}

func (y ymDataRawDo) Preload(fields ...field.RelationField) IYmDataRawDo {
	for _, _f := range fields {
		y = *y.withDO(y.DO.Preload(_f))
	}
	return &y
}

func (y ymDataRawDo) FirstOrInit() (*model.YmDataRaw, error) {
	if result, err := y.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.YmDataRaw), nil
	}
}

func (y ymDataRawDo) FirstOrCreate() (*model.YmDataRaw, error) {
	if result, err := y.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.YmDataRaw), nil
	}
}

func (y ymDataRawDo) FindByPage(offset int, limit int) (result []*model.YmDataRaw, count int64, err error) {
	result, err = y.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = y.Offset(-1).Limit(-1).Count()
	return
}

func (y ymDataRawDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = y.Count()
	if err != nil {
		return
	}

	err = y.Offset(offset).Limit(limit).Scan(result)
	return
}

func (y ymDataRawDo) Scan(result interface{}) (err error) {
	return y.DO.Scan(result)
}

func (y ymDataRawDo) Delete(models ...*model.YmDataRaw) (result gen.ResultInfo, err error) {
	return y.DO.Delete(models)
}

func (y *ymDataRawDo) withDO(do gen.Dao) *ymDataRawDo {
	y.DO = *do.(*gen.DO)
	return y
}
