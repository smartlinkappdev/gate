// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"cmd/gate/main.go/internal/model"
)

func newSlAnalytic(db *gorm.DB, opts ...gen.DOOption) slAnalytic {
	_slAnalytic := slAnalytic{}

	_slAnalytic.slAnalyticDo.UseDB(db, opts...)
	_slAnalytic.slAnalyticDo.UseModel(&model.SlAnalytic{})

	tableName := _slAnalytic.slAnalyticDo.TableName()
	_slAnalytic.ALL = field.NewAsterisk(tableName)
	_slAnalytic.SlName = field.NewString(tableName, "sl_name")
	_slAnalytic.Sessions = field.NewString(tableName, "sessions")
	_slAnalytic.TotalSessions = field.NewInt32(tableName, "total_sessions")

	_slAnalytic.fillFieldMap()

	return _slAnalytic
}

type slAnalytic struct {
	slAnalyticDo

	ALL           field.Asterisk
	SlName        field.String
	Sessions      field.String
	TotalSessions field.Int32

	fieldMap map[string]field.Expr
}

func (s slAnalytic) Table(newTableName string) *slAnalytic {
	s.slAnalyticDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s slAnalytic) As(alias string) *slAnalytic {
	s.slAnalyticDo.DO = *(s.slAnalyticDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *slAnalytic) updateTableName(table string) *slAnalytic {
	s.ALL = field.NewAsterisk(table)
	s.SlName = field.NewString(table, "sl_name")
	s.Sessions = field.NewString(table, "sessions")
	s.TotalSessions = field.NewInt32(table, "total_sessions")

	s.fillFieldMap()

	return s
}

func (s *slAnalytic) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *slAnalytic) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 3)
	s.fieldMap["sl_name"] = s.SlName
	s.fieldMap["sessions"] = s.Sessions
	s.fieldMap["total_sessions"] = s.TotalSessions
}

func (s slAnalytic) clone(db *gorm.DB) slAnalytic {
	s.slAnalyticDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s slAnalytic) replaceDB(db *gorm.DB) slAnalytic {
	s.slAnalyticDo.ReplaceDB(db)
	return s
}

type slAnalyticDo struct{ gen.DO }

type ISlAnalyticDo interface {
	gen.SubQuery
	Debug() ISlAnalyticDo
	WithContext(ctx context.Context) ISlAnalyticDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISlAnalyticDo
	WriteDB() ISlAnalyticDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISlAnalyticDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISlAnalyticDo
	Not(conds ...gen.Condition) ISlAnalyticDo
	Or(conds ...gen.Condition) ISlAnalyticDo
	Select(conds ...field.Expr) ISlAnalyticDo
	Where(conds ...gen.Condition) ISlAnalyticDo
	Order(conds ...field.Expr) ISlAnalyticDo
	Distinct(cols ...field.Expr) ISlAnalyticDo
	Omit(cols ...field.Expr) ISlAnalyticDo
	Join(table schema.Tabler, on ...field.Expr) ISlAnalyticDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISlAnalyticDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISlAnalyticDo
	Group(cols ...field.Expr) ISlAnalyticDo
	Having(conds ...gen.Condition) ISlAnalyticDo
	Limit(limit int) ISlAnalyticDo
	Offset(offset int) ISlAnalyticDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISlAnalyticDo
	Unscoped() ISlAnalyticDo
	Create(values ...*model.SlAnalytic) error
	CreateInBatches(values []*model.SlAnalytic, batchSize int) error
	Save(values ...*model.SlAnalytic) error
	First() (*model.SlAnalytic, error)
	Take() (*model.SlAnalytic, error)
	Last() (*model.SlAnalytic, error)
	Find() ([]*model.SlAnalytic, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SlAnalytic, err error)
	FindInBatches(result *[]*model.SlAnalytic, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.SlAnalytic) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISlAnalyticDo
	Assign(attrs ...field.AssignExpr) ISlAnalyticDo
	Joins(fields ...field.RelationField) ISlAnalyticDo
	Preload(fields ...field.RelationField) ISlAnalyticDo
	FirstOrInit() (*model.SlAnalytic, error)
	FirstOrCreate() (*model.SlAnalytic, error)
	FindByPage(offset int, limit int) (result []*model.SlAnalytic, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISlAnalyticDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s slAnalyticDo) Debug() ISlAnalyticDo {
	return s.withDO(s.DO.Debug())
}

func (s slAnalyticDo) WithContext(ctx context.Context) ISlAnalyticDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s slAnalyticDo) ReadDB() ISlAnalyticDo {
	return s.Clauses(dbresolver.Read)
}

func (s slAnalyticDo) WriteDB() ISlAnalyticDo {
	return s.Clauses(dbresolver.Write)
}

func (s slAnalyticDo) Session(config *gorm.Session) ISlAnalyticDo {
	return s.withDO(s.DO.Session(config))
}

func (s slAnalyticDo) Clauses(conds ...clause.Expression) ISlAnalyticDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s slAnalyticDo) Returning(value interface{}, columns ...string) ISlAnalyticDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s slAnalyticDo) Not(conds ...gen.Condition) ISlAnalyticDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s slAnalyticDo) Or(conds ...gen.Condition) ISlAnalyticDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s slAnalyticDo) Select(conds ...field.Expr) ISlAnalyticDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s slAnalyticDo) Where(conds ...gen.Condition) ISlAnalyticDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s slAnalyticDo) Order(conds ...field.Expr) ISlAnalyticDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s slAnalyticDo) Distinct(cols ...field.Expr) ISlAnalyticDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s slAnalyticDo) Omit(cols ...field.Expr) ISlAnalyticDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s slAnalyticDo) Join(table schema.Tabler, on ...field.Expr) ISlAnalyticDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s slAnalyticDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISlAnalyticDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s slAnalyticDo) RightJoin(table schema.Tabler, on ...field.Expr) ISlAnalyticDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s slAnalyticDo) Group(cols ...field.Expr) ISlAnalyticDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s slAnalyticDo) Having(conds ...gen.Condition) ISlAnalyticDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s slAnalyticDo) Limit(limit int) ISlAnalyticDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s slAnalyticDo) Offset(offset int) ISlAnalyticDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s slAnalyticDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISlAnalyticDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s slAnalyticDo) Unscoped() ISlAnalyticDo {
	return s.withDO(s.DO.Unscoped())
}

func (s slAnalyticDo) Create(values ...*model.SlAnalytic) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s slAnalyticDo) CreateInBatches(values []*model.SlAnalytic, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s slAnalyticDo) Save(values ...*model.SlAnalytic) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s slAnalyticDo) First() (*model.SlAnalytic, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.SlAnalytic), nil
	}
}

func (s slAnalyticDo) Take() (*model.SlAnalytic, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.SlAnalytic), nil
	}
}

func (s slAnalyticDo) Last() (*model.SlAnalytic, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.SlAnalytic), nil
	}
}

func (s slAnalyticDo) Find() ([]*model.SlAnalytic, error) {
	result, err := s.DO.Find()
	return result.([]*model.SlAnalytic), err
}

func (s slAnalyticDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.SlAnalytic, err error) {
	buf := make([]*model.SlAnalytic, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s slAnalyticDo) FindInBatches(result *[]*model.SlAnalytic, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s slAnalyticDo) Attrs(attrs ...field.AssignExpr) ISlAnalyticDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s slAnalyticDo) Assign(attrs ...field.AssignExpr) ISlAnalyticDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s slAnalyticDo) Joins(fields ...field.RelationField) ISlAnalyticDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s slAnalyticDo) Preload(fields ...field.RelationField) ISlAnalyticDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s slAnalyticDo) FirstOrInit() (*model.SlAnalytic, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.SlAnalytic), nil
	}
}

func (s slAnalyticDo) FirstOrCreate() (*model.SlAnalytic, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.SlAnalytic), nil
	}
}

func (s slAnalyticDo) FindByPage(offset int, limit int) (result []*model.SlAnalytic, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s slAnalyticDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s slAnalyticDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s slAnalyticDo) Delete(models ...*model.SlAnalytic) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *slAnalyticDo) withDO(do gen.Dao) *slAnalyticDo {
	s.DO = *do.(*gen.DO)
	return s
}
